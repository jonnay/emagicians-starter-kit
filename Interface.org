#+Title: User Interface Elements

* Keystrokes and commands
** Simple answers plz!
#+begin_src emacs-lisp 
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** It used to be that Once in blue moon, vi keys would happen  :history:
   That was before I really dug into Tramp mode.

   I would launch vim to edit a file on a remote server.  I know just
   enough vi to add characters and save and get out.  In fact, I would
   save with: ~<ESC>:w~ and then quit with ~<ESC>:q!~.  Not even
   ~<ESC>:wq!~

   This would hose my muscle memory though.  And sometimes I would try
   to do the same in emacs.

   By setting the var ~w~ to the string, when it is evaled with ESC-:
   the string is evaled instead.

#+begin_src emacs-lisp :tangle no
  (setq w! "uUuuuuuUUUuuuummmMMMmmmm.  This ain't vim.")
#+end_src

   Now that I can do most of everything I need through tramp, and the
   stuff I can't do I can from within a shell inside of emacs, this
   isn't needed anymore.

   I keep it around (but don't load it) because it's clevar and fun.

* Automated things
** Midnight  :automation:
   Clean some buffers at midnight.

#+begin_src emacs-lisp 
(use-package midnight
  :init
  (setq clean-buffer-list-kill-never-buffer-names '("*httpd*"))
  :config
  (midnight-delay-set 'midnight-delay "4:30am"))
#+end_src

* Display   :display:

There is an argument that Emacs doesn't need to look pretty.  That all we're really doing is editing text, so why do anything to it beyond a basic theme to give you syntax colors.

I call bullshit.  All of us already live in a prison of existential crisis.  Why would we make our text editor any more of a prison?

I eat delicious food, not soylent.

I drink excellent beer, not MGD. 

Aesthetics are important.

** Turn of scrollbars, toolbars, menu bars

All that said, there are some shit that is just ... not good.

Scrollbars, Toolbars and Menu Bars. Oh my.

#+begin_src emacs-lisp 
(dolist (mode '(menu-bar-mode tool-bar-mode scroll-bar-mode))
    (when (fboundp mode) (funcall mode -1)))
#+end_src

** üõé Bell üîî
   When emacs emits C-g (bell) to the user, it is to signal an error,
   warning or some other alert.

   When the user types C-g to emacs, it is to signal an error, or a
   need to quit.

   I rather enjoy that kind of poetry.

   I used to hate the visible bell when it flashed the whole screen,
   but it has sense gotten a lot better.  It flashes two bars at the
   top and bottom now rather than the whole screen, and is nice when
   you don't have the volume up.

#+begin_src emacs-lisp 
(setq visible-bell t)
#+end_src

** Fonts

   Font choice is very important aesthetically speaking.  I am however failing at this somewaht. 

*** Describe Char
   Give us all the unicode information for a glyph.
#+begin_src emacs-lisp 
(setq describe-char-unidata-list '(name old-name general-category canonical-combining-class bidi-class decomposition decimal-digit-value digit-value numeric-value mirrored uppercase lowercase titlecase))
#+end_src

*** Unicode
#+begin_verse
Unicode
  |(‚ÅÄ‚Çí‚ÅÄ)/    ,(   Get all teh characters! )
#+end_verse

The ~unicode-fonts~ package does a pretty good job of helping you get to a place where all characters can be displayed.  

You'll need a number of fonts to make this work, here is the bare minimum:
- Symbola :: http://users.teilar.gr/~g1951d/Symbola.zip
- Quivira :: http://www.quivira-font.com/files/Quivira.ttf
- Dejavu Sans :: http://sourceforge.net/projects/dejavu/files/dejavu/2.35/dejavu-fonts-ttf-2.35.tar.bz2
- Noto Sans :: https://github.com/googlei18n/noto-fonts/blob/master/hinted/NotoSans-Regular.ttc?raw=true
- Noto Sans Symbols :: https://github.com/googlei18n/noto-fonts/blob/master/unhinted/NotoSansSymbols-Regular.ttf?raw=true

Really though, the key here is being able to get all the emoji.

The secret sauce to making sure to get all the emoji is ~(setq unicode-fonts-ignore-overrides t)~

#+begin_verse
  üëØ ,( Get all teh Emoji! )
#+end_verse

#+begin_src emacs-lisp 
(use-package unicode-fonts
  :demand
  :init
  (setq unicode-fonts-skip-fonts)
  (setq unicode-fonts-ignore-overrides t)
  (use-package persistent-soft :demand)
  :config
  (unicode-fonts-setup))
#+end_src

** Ansi Color
   ARGH, we were so close to getting away from this until hipsters brought it all back again.

   Thanks Obama.

#+begin_src emacs-lisp 
(require 'ansi-color)
#+end_src

** Maximize primary window

   This seems to be the best way to get emacs to be maximized on the primary display in a multi monitor setup.  At least on OS X.

#+begin_src emacs-lisp 
(setq default-frame-parameters '((fullscreen . maximized)))
(defun emagician/full-screen ()
  "Fullscreen mode!"
  (interactive)
  (modify-frame-parameters nil '((fullscreen . maximized))))
(emagician/full-screen)
#+end_src

** Soft Word Wrap / Visual Line Mode

   "Visual Line Mode" is probably the worst name ever.  

#+begin_src emacs-lisp 
(emagician/defhook unmap-visual-line-mode-keys global-visual-line-mode-hook
  (unbind-key "<remap> <kill-visual-line>" visual-line-mode-map)
  (unbind-key "<remap> <beginning-visual-line>" visual-line-mode-map)
  (unbind-key "<remap> <end-of-visual-line>" visual-line-mode-map))
(setq visual-line-fringe-indicators t)
(global-visual-line-mode 1)
#+end_src

Indicators Plz!

#+begin_src emacs-lisp :tangle no

#+end_src

*** Movement commands 

** Frame titles
   Shamelessly snarfed from batsov.

   Shows either the full file path or buffer name, and the name of the process when available.  

#+begin_src emacs-lisp 
(setq frame-title-format
      '(""
        invocation-name
        "  -|-+-|-  "
        (:eval (if (buffer-file-name)
                   (abbreviate-file-name (buffer-file-name))
                 "%b"))
        (:eval (when (get-buffer-process (current-buffer))
                 (format "[%s]" (process-name (get-buffer-process (current-buffer))))))))
#+end_src

** Modeline
The modeline should show as much information as required, in as small a space as possible.

*** Basics
#+begin_src emacs-lisp 
(setq column-number-mode t)
(setq line-number-mode t)
#+end_src

*** Diminish

    I am not sure if it is Author: Will Mengarini, or Maintainer:
    Martin Yrj√∂l√§ who came up with this, but it is the most poetic
    commentary in any lisp file I have seen so far:

#+begin_src emacs-lisp :tangle no
;; When we diminish a mode, we are saying we want it to continue doing its
;; work for us, but we no longer want to be reminded of it.  It becomes a
;; night worker, like a janitor; it becomes an invisible man; it remains a
;; component, perhaps an important one, sometimes an indispensable one, of
;; the mechanism that maintains the day-people's world, but its place in
;; their thoughts is diminished, usually to nothing.  As we grow old we
;; diminish more and more such thoughts, such people, usually to nothing.

;; "The wise man knows that to keep under is to endure."  The diminished
;; often come to value their invisibility.  We speak--speak--of "the strong
;; silent type", but only as a superficiality; a stereotype in a movie,
;; perhaps, but even if an acquaintance, necessarily, by hypothesis, a
;; distant one.  The strong silent type is actually a process.  It begins
;; with introspection, continues with judgment, and is shaped by the
;; discovery that these judgments are impractical to share; there is no
;; appetite for the wisdom of the self-critical among the creatures of
;; material appetite who dominate our world.  Their dominance's Darwinian
;; implications reinforce the self-doubt that is the germ of higher wisdom.
;; The thoughtful contemplate the evolutionary triumph of the predator.
;; Gnostics deny the cosmos could be so evil; this must all be a prank; the
;; thoughtful remain silent, invisible, self-diminished, and discover,
;; perhaps at first in surprise, the freedom they thus gain, and grow strong.
#+end_src

So yeah.  It's a great mode to have around, but there's that too.

#+begin_src emacs-lisp 
(use-package diminish)
(diminish 'visual-line-mode "‚Ü©Ô∏è ")

(use-package autorevert
  :diminish (auto-revert-mode . "üîÇ "))
#+end_src

*** Nyan mode
One day.  Powerline and nyan mode don't work.
#+begin_src emacs-lisp 
(use-package nyan-mode
  :init
  (setq nyan-wavy-trail t)
  (setq nyan-bar-length 10)
  (setq nyan-animate-nyancat t))
#+end_src

*** Turn on column and line numbers; file size
#+begin_src emacs-lisp 
(column-number-mode 1)
(line-number-mode 1)
(size-indication-mode t)
#+end_src

*** Powerline
**** The EMagician powerline theme
Inludes Nyan cat powers.
#+begin_src emacs-lisp 
(defun emagician/powerline-theme ()
  "Setup the default mode-line."
  (interactive)
  (setq-default mode-line-format
                '("%e"
                  (:eval
                   (let* ((active (powerline-selected-window-active))
                          (mode-line-buffer-id (if active 'mode-line-buffer-id 'mode-line-buffer-id-inactive))
                          (mode-line (if active 'mode-line 'mode-line-inactive))
                          (face1 (if active 'powerline-active1 'powerline-inactive1))
                          (face2 (if active 'powerline-active2 'powerline-inactive2))
                          (separator-left (intern (format "powerline-%s-%s"
                                                          (powerline-current-separator)
                                                          (car powerline-default-separator-dir))))
                          (separator-right (intern (format "powerline-%s-%s"
                                                           (powerline-current-separator)
                                                           (cdr powerline-default-separator-dir))))
                          (lhs (list (powerline-raw "%*" mode-line 'l)
                                     (powerline-buffer-size mode-line 'l)
                                     (powerline-buffer-id mode-line-buffer-id 'l)
                                     (powerline-raw " ")
                                     (funcall separator-left mode-line face1)
                                     (powerline-narrow face1 'l)
                                     (powerline-vc face1)))
                          (rhs (list (powerline-raw global-mode-string face1 'r)
                                     (powerline-raw "%4l" face1 'r)
                                     (powerline-raw ":" face1)
                                     (powerline-raw "%3c" face1 'r)
                                     (funcall separator-right face1 mode-line)
                                     (powerline-raw " ")
                                     (powerline-raw "%6p" mode-line 'r)
                                     (powerline-hud face2 face1)))
                          (center (list (powerline-raw " " face1)
                                        (funcall separator-left face1 face2)
                                        (when (and (boundp 'erc-track-minor-mode) erc-track-minor-mode)
                                          (powerline-raw erc-modified-channels-object face2 'l))
                                        (powerline-major-mode face2 'l)
                                        (powerline-process face2)
                                        (powerline-raw " :" face2)
                                        (powerline-minor-modes face2 'l)
                                        (powerline-raw " " face2)
                                        (nyan-create)
                                        (powerline-raw " " face2)
                                        (funcall separator-right face2 face1))))
                     (concat (powerline-render lhs)
                             (powerline-fill-center face1 (/ (powerline-width center) 2.0))
                             (powerline-render center)
                             (powerline-fill face1 (powerline-width rhs))
                             (powerline-render rhs)))))))
#+end_src
**** Other settings

     Available Separators are:
alternate, arrow, arrow-fade, bar, box, brace, butt,
chamfer, contour, curve, rounded, roundstub, slant, wave, zigzag

#+begin_src emacs-lisp 
  (use-package powerline
               :demand
               :init
               (setq powerline-default-separator 'rounded)
               (emagician/powerline-theme))
#+end_src
*** Smart Mode Line
#+begin_src  emacs-lisp 
(emagician/expect-package 'smart-mode-line)
#+end_src

** Cursor Info
   There are a few ways to change the cursor: blinking, shape and
   color.  Basically this gives us three different dimensions of
   information available to us.

*** Dimension 1: File status
   	- light blue :: no file or process attached
   	- dark blue :: process attached
   	- yellow :: read only
    - red :: Important (SSH to production server, etc)
   	- grey :: file visited

*** Dimention 2: Funky modes
   	- overwrite :: hollow box
   	- 'normal' :: line

*** Enhancements
**** TODO set up a way to handle production buffers through a buffer local var.

#+name: cursor-status
#+begin_src emacs-lisp 
  ;; Change cursor color according to mode
  (defvar emagician/set-cursor-color-color "")
  (defvar emagician/set-cursor-color-type nil)
  (defvar emagician/set-cursor-color-buffer "")

  (defun emagician/set-cursor-color-according-to-mode ()
    "change cursor color according to some minor modes."
    ;; set-cursor-color is somewhat costly, so we only call it when needed:
    (let ((color (cond

                  ((comint-check-proc (current-buffer)) "blue")
                  (buffer-read-only "white")
                  ((not (equal buffer-file-name nil)) "grey50")
                  (t "cyan")))
          (type (cond
                 (overwrite-mode 'hollow)
                 (t 'box))))
      (unless (and
               (string= color emagician/set-cursor-color-color)
               (string= type emagician/set-cursor-color-type)
               (string= (buffer-name) emagician/set-cursor-color-buffer))
        (set-cursor-color (setq emagician/set-cursor-color-color color))
        (setq cursor-type (setq emagician/set-cursor-color-type type))
        (setq emagician/set-cursor-color-buffer (buffer-name)))))

  (add-hook 'post-command-hook 'emagician/set-cursor-color-according-to-mode)
#+end_src

** Highlight Line
#+begin_src emacs-lisp 
(global-hl-line-mode 1)
#+end_src

** Show Empty lines
#+begin_src emacs-lisp 
(setq indicate-empty-lines t)
#+end_src

** Show Whitespace with fill-column-indicator                                            :deactived:
   I was initially using fill-column-indicator, but that turned out to
   be kinda buggy.   It looks  It would hose org exports and also whack
   visual-line-mode.

   See [[file:Programming.org::*Show%20whitespace][Show whitespace in Programming.org]]

#+begin_src emacs-lisp :tangle no
(use-package fill-column-indicator
  :init
  (setq fci-rule-width 1)
  (setq fci-rule-column 81)
  (define-globalized-minor-mode global-fci-mode fci-mode (lambda () (fci-mode 1)))
  (global-fci-mode 1))
#+end_src

** Themes
*** Base theme: Moe, Moe, Kyun!
   This theme is my favorite so far.  It's got good color choices and it's nice and dark.

**** Set up different colors for different days

     The colors are:

     | Day       | apsect      | Color   | ‚ò∞  |
     |-----------+-------------+---------+---|
     | Sunday    | Benevolence | yellow  | üåû |
     | Monday    | Reverence   | blue    | üåö |
     | Tuesday   | Courage     | red     | ‚ôÇ |
     | Wednesday | Honesty     | cyan    | ‚òø |
     | Thursday  | Rectitude   | green   | ‚ôÉ |
     | Friday    | Honour      | magenta | ‚ôÄ |
     | Saturday  | Loyalty     | b/w     | ‚ôÑ |

#+begin_src emacs-lisp 
(defun emagician/get-moe-color-for-day (&optional day)
  (when (null day)
    (setq day (nth 6 (decode-time))))
  (case day
    ((0) 'yellow)
    ((1) 'blue)
    ((2) 'red)
    ((3) 'cyan)
    ((4) 'green)
    ((5) 'magenta)
    ((6) 'w/b)))

(ert-deftest emagician/color-check ()
  (should (equal (emagician/get-moe-color-for-day 1)
                 'blue))
  (should (equal (emagician/get-moe-color-for-day 5)
                 'magenta))
  (should (member (emagician/get-moe-color-for-day)
                  '(yellow blue red cyan green magenta w/b))))
#+end_src


**** Main setup

   The theme needs to be loaded after powerline to work.
#+begin_src emacs-lisp  
(use-package moe-theme
  :init
  (setq moe-theme-highlight-buffer-id t)
  :config
  (emagician/defhook update-moe-color midnight-hook
    (moe-theme-set-color (emagician/get-moe-color-for-day))
    (emagician/powerline-theme))
  (moe-theme-set-color (emagician/get-moe-color-for-day))
  (moe-dark)
  (powerline-moe-theme)
  (emagician/powerline-theme)
  (powerline-reset)
)
#+end_src
*** Org Beautify
    Load from our bad self!
#+begin_src emacs-lisp 
  (add-to-list 'custom-theme-load-path (expand-file-name "themes/org-beautify-theme/" emagician/dir))
  (load-theme 'org-beautify t)
#+end_src

** Digit Groups                                                                        :deactivated:
   Currently a little buggy, completely overrides my theme. 

   Group Numbers together into thousands, millions, billions.

   10000000000

   Looks like this:

#+BEGIN_EXAMPLE
   10000000000
   --   ---
#+END_EXAMPLE

#+begin_src emacs-lisp :tangle no
(use-package digit-groups
  :demand
  :init
  (digit-groups-global-mode 1))
#+end_src

* Editing
** UTF-8 Enforcement
  I've kept a version of this since 2006.

#+begin_src emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
#+end_src

** The Mark
*** Transient mark mode

  For now Transient Mark mode is just turned off.  I don't like
  transients.

  Seriously though, the reason why I like not having transient mark
  mode is that I have gotten into the habit of dropping marks and
  using the mark ring.  I also use the mark for nagivation, and having
  transient mark mode on messes with my workflow.

  If you are opposite, then let me know (file a bug report:
  https://github.com/jonnay/emagicians-starter-kit/issues/new) and
  I'll fix the emagicians kit so that transient mark mode can be
  easily activated.

#+name: turn-off-transient-mark
#+begin_src emacs-lisp
  (transient-mark-mode -1)
#+end_src

*** Show Marks   :learn-me:
#+begin_src emacs-lisp
(use-package show-marks)
#+end_src

** Multiple Cursors                                                                           :bind:

   Note that this is a great example of building your own custom
   keymap and using it with use-package.[fn:2]

#+begin_src emacs-lisp
(use-package multiple-cursors
  :init
  (define-prefix-command 'emagician/mc-keymap)
  :bind-keymap (("C-S-c" . emagician/mc-keymap))
  :bind (:map emagician/mc-keymap
              ("e" . mc/edit-lines)
              ("n" . mc/mark-next-like-this)
              ("p" . mc/mark-previous-like-this)
              (")" . mc/mark-next-symbol-like-this)
              ("(" . mc/mark-prev-symbol-like-this)
              ("h" . mc/mark-all-like-this)
              ("s" . mc/mark-all-in-region)
              ("f" . mc/unmark-next-like-this)
              ("F" . mc/skip-to-next-like-this)
              ("b" . mc/unmark-previous-like-this)
              ("B" . mc/skip-to-previous-like-this)))
#+end_src

** Killing and Yanking
   Having a big kill ring is very helpful.  It's searchable by helm.

#+begin_src emacs-lisp
(setq kill-ring-max 120)
#+end_src

   Also, the system clipboard is a must have.

#+begin_src emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+end_src

   Allow Read-only killing.  Being able to throw chunks of a read-only buffer is so powerful.  It's one of the things I love about emacs.

The Power of plain text.

#+begin_src emacs-lisp
(setq kill-read-only-ok t)
#+end_src

Kill-whole-line just blew chunks for me.  REALLY blew chunks.

#+begin_src emacs-lisp
(setq kill-whole-line nil)
#+end_src

*** Volatile Highlights
   Shows what changed through undo, yank etc. commands

#+begin_src emacs-lisp
  (use-package volatile-highlights
    :diminish ""
    :init
    (volatile-highlights-mode t))
#+end_src

*** Swap
Found from Stackoverflow.  Thank you jcubic and legoscia.[fn:1]

#+begin_src emacs-lisp
(defun swap-region-with-kill (&optional arg)
  "replace selected text with the one from kill ring"
  (interactive "*P")
  (backward-delete-char (- (point) (mark)))
  (yank arg))
#+end_src

*** kill-buffer-file-name
    I use this all the time.

#+begin_src emacs-lisp
  (defun kill-buffer-file-name ()
    "Show current buffer's filename in the echo area and add it to the kill ring."
    (interactive)
    (let ((buffer-file-name (buffer-file-name)))
      (if (null buffer-file-name)
          (message "Buffer %s is not associated with a file." (buffer-name))
        (message "%s" (kill-new buffer-file-name)))))
#+end_src

#+begin_src emacs-lisp
    (defun kill-buffer-file-basename ()
      "Show the buffers base name in the echo area and add it to the kill ring."
      (interactive)
      (let ((bufer-file-name (buffer-file-name)))
        (if (not (null buffer-file-name))
            (message "%s" (kill-new (file-name-nondirectory buffer-file-name)))
          (error "Buffer %s is not associated with a file" (buffer-name)))))
#+end_src

** Snippets

   See also [[./Snippets.org]] for the actual Snippets.

   Set the snippet dir.

(emagician/expect-dir "assets/snippets")
#+begin_src emacs-lisp 
(use-package yasnippet
  :diminish ""
  :init
  (setq yas-snippet-dirs `(,(expand-file-name "assets/snippets" emagician/dir) yas-installed-snippets-dir))
  (setq yas-trigger-key nil)
  (add-hook 'text-mode-hook 'yas-minor-mode-on)
  :config
  (diminish 'yas-minor-mode "")
  (yas/reload-all))
#+end_src

   This rigamaroo might nit be needed anymore:

#+begin_src emacs-lisp :tangle no
 (defun yas/org-very-safe-expand ()
    (let ((yas/fallback-behavior 'return-nil)) (yas/expand)))

  (defun yas/org-setup ()
    ;; yasnippet (using the new org-cycle hooks)
    (make-variable-buffer-local 'yas/trigger-key)
    (setq yas/trigger-key [tab])
    (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
    (define-key yas/keymap [tab] 'yas/next-field))

  ;(add-hook 'org-mode-hook #'yas/org-setup)

#+end_src

** Completion  :completion:
*** Company Mode

#+begin_src emacs-lisp
(use-package company
  :diminish "üà∫ "
  :init
  (global-company-mode)
  (use-package company-quickhelp
    :init
    (setq company-quickhelp-idle-delay 0.25)))
#+end_src

*** Auto Complete

    It's time to switch.  AC hasn't really changed that much, and it is starting to look awful.


   *Note:* if you were looking for the AC sources for a particular language or mode, then you will want to look in those specific language/mode emagician files.

   `ac-ignore-case` is really burning me right now, so I am enabling it.

#+begin_src emacs-lisp :tangle no
(use-package auto-complete
  :demand
  :diminish ""
  :init
  (setq ac-auto-show-menu t)
  (setq ac-dwim t)
  (setq ac-use-menu-map t)
  (setq ac-ignore-case nil)
  (setq ac-quick-help-delay (+ 0.125 (/ 0.125 2)))
  (setq ac-quick-help-height 20)
  (set-default 'ac-sources
               '(ac-source-yasnippet
                 ac-source-dictionary
                 ac-source-filename
                 ac-source-files-in-current-dir
                 ac-source-words-in-buffer
                 ac-source-words-in-same-mode-buffers))
  :bind
  (:map ac-completing-map
        ("C-M-n"   . ac-next)
        ("C-M-p"   . ac-previous)
        ("<tab>"   . ac-complete)
        ("M-<ret>" . ac-help)
        ("<ret>"   . nil))

  :config
  (require 'auto-complete-config)
  (ac-config-default)
  (ac-flyspell-workaround)
  (global-auto-complete-mode t)
  (emagician/expect-dir "assets/ac-dictionaries")
  (add-to-list 'ac-dictionary-directories (expand-file-name "assets/ac-dictionaries" emagician/dir)))
#+end_src

**** Auto Complete Default Sources :tangle no
#+begin_src emacs-lisp
  (set-default 'ac-sources
               '(ac-source-yasnippet
                 ac-source-dictionary
                 ac-source-words-in-buffer
                 ac-source-words-in-same-mode-buffers))
#+end_src

** Undo
#+begin_src emacs-lisp
  (use-package undo-tree
    :diminish ""
    :init
    (setq undo-tree-enable-undo-in-region t
          undo-tree-visualizer-diff t
          undo-tree-zer-timestamps t)
    :config
    (global-undo-tree-mode))
#+end_src

** Spell Checking
#+begin_src emacs-lisp 

(use-package flyspell
  :diminish (flyspell-mode . ""))
#+end_src

* Navigating
** Scrolling
   Keep the screen position when scrolling.

  #+begin_src emacs-lisp
(setq scroll-preserve-screen-position t)
  #+end_src

** Avy                                                                                       :learn:
   Basically Acejump++.

#+begin_src emacs-lisp
(use-package avy
  :bind
  (("M-g f" . avy-goto-line)
    ("M-g h" . avy-goto-char-2)
    ("M-g i" . avy-goto-char)))
#+end_src
** Ace window jump
   - Set the keys to home-row
   - Make the ace-jump key super visible
   - Only apply to this frame

#+begin_src emacs-lisp
(use-package ace-window
  :init
  (face-spec-set
   'aw-leading-char-face
     '((t (:inherit avy-lead-face :height 3.0))))
  (setq aw-scope 'frame)
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  :bind
  ("C-x o" . ace-window))
#+end_src

** Save Place
   Saveplace allows emacs to remember where you were in a file.  It is very handy and mostly transparent.
#+begin_src emacs-lisp
(require 'saveplace)
(setq-default save-place t)
#+end_src

** Goto Last Change                                                                          :learn:
#+begin_src emacs-lisp
(use-package goto-last-change
  :bind
  ("C-x C-/" . goto-last-change))
#+end_src

** Uniquify

   Rename buffers so they are unique.

#+begin_src emacs-lisp
  (require 'uniquify)
#+end_src

** Searching
*** Default to regexp Searches
#+begin_src emacs-lisp
(global-set-key [(control s)] 'isearch-forward-regexp)
(global-set-key [(control r)] 'isearch-backward-regexp)
#+end_src

* Saving
** Backups
   Disabling backups was a monumentally stupidly bad idea.  I shall never do it again.

#+begin_src emacs-lisp
(setq auto-save-default t)
#+end_src

*** Set the backup directory to something decent
(emagician/expect-dir "backups")

#+begin_src emacs-lisp
(setq backup-directory-alist
      `(("." . ,(expand-file-name
                 (concat user-emacs-directory "backups")))))

(setq tramp-backup-directory-alist backup-directory-alist)

;; Make backups of files, even when they're in version control
(setq vc-make-backup-files t)
#+end_src

* State Management
** Server
#+begin_src emacs-lisp
(unless (string-equal "root" (getenv "USER"))
  (require 'server)
  (unless (server-running-p) (server-start)))
#+end_src

** Recent Files
   500 should be as enough files to handle long editing sessions at
   work, and some weekend projects as well.

#+begin_src emacs-lisp
  (require 'recentf)
  (setq recentf-max-saved-items 500)
#+end_src

** Save Command History
#+begin_src emacs-lisp
(setq savehist-additional-variables '(search-ring regexp-search-ring kill-ring compile-command ))
(setq savehist-autosave-interval 60)
(savehist-mode t)
#+end_src

* Help and Discoverability                                                                    :help:
** Achievements
#+begin_src emacs-lisp  :tangle no
(use-package achievements
  :demand
  :diminish "üèÜ "
  :init
  (setq achievements-idle-time 300))
#+end_src

** Which Key
   More like‚Äîwitch key.  Which-key is the ultimate in discoverability.

#+begin_src emacs-lisp
(use-package which-key
  :demand
  :diminish ""
  :init
  (setq which-key-idle-delay 0.6)
  (setq which-key-is-verbose t)
  (setq which-key-min-display-lines 3)
  (setq which-key-sort-order 'which-key-local-then-key-order)
  (setq which-key-max-description-length 50)
  (setq which-key-show-remaining-keys t)
  (setq which-key-lighter "‚ùî")
  (which-key-mode))
#+end_src

** Discover My Major   :learn-me:bind:
#+begin_src emacs-lisp
  (use-package discover-my-major
    :bind
    (("C-c C-h"   . discover-my-major)
     ("C-c C-S-H" . discover-my-mode)))
#+end_src


** Helm
#+name: helm
#+begin_src emacs-lisp 
(use-package helm
  :demand
  :diminish (helm-mode . "")
  :init
  (global-set-key [f2] 'emagician/helm)
  (require 'helm-config)
  (require 'helm-ring)
  (use-package helm-ls-git :demand))
#+end_src

*** F2 is my super duper DWIM helper
#+begin_src emacs-lisp
  (defun emagician/helm-old ()
    "Slowly going to become a super helm-dwim"
    (interactive)
    (require 'helm-files)
    (unless (and helm-source-ls-git-status
                 helm-source-ls-git)
      (setq helm-source-ls-git-status
            (helm-make-source "Git status" 'helm-ls-git-status-source
              :fuzzy-match helm-ls-git-fuzzy-match)
            helm-source-ls-git
            (helm-make-source "Git files" 'helm-ls-git-source
              :fuzzy-match helm-ls-git-fuzzy-match)))
    (unless helm-source-buffers-list
      (setq helm-source-buffers-list
            (helm-make-source "Buffers" 'helm-source-buffers)))

      (helm-other-buffer '(helm-source-buffers-list
                           helm-source-files-in-current-dir
                           helm-source-ls-git-status
                           helm-source-ls-git
                           helm-source-mark-ring
                           helm-source-bookmarks
                           helm-source-recentf
                           helm-source-global-mark-ring
                           helm-source-buffer-not-found)
                         "*helm mini*"))

#+end_src

#+begin_src emacs-lisp 
(defun emagician/helm ()
  "Super powered helm mode to DWIM!"
  (interactive)
  (unless helm-source-buffers-list
    (setq helm-source-buffers-list
          (helm-make-source "Buffers" 'helm-source-buffers)))
  (helm :sources
        '(helm-source-buffers-list
          helm-source-files-in-current-dir
          helm-source-ls-git-status
          helm-source-ls-git
          helm-source-mark-ring
          helm-source-bookmarks
          helm-source-recentf
          helm-source-register
          helm-source-buffer-not-found)))
#+end_src

*** Enable it
#+begin_src emacs-lisp 
(helm-mode 1)
#+end_src

*** Helm for M-x
#+begin_src emacs-lisp 
  (global-set-key (kbd "M-x")     'helm-M-x)
  (setq helm-M-x-always-save-history t)
#+end_src

**** Key binding muscle memory
     See [[file:Lamp.org::*Fix-Muscle-Memory%20(was%20Emagician-Fix-Spell)][Fix-Muscle-Memory (was Emagician-Fix-Spell)]]
*** Buffer Selection
#+begin_src emacs-lisp 
(global-set-key (kbd "C-x b") 'helm-buffers-list)
#+end_src

*** Show full paths
#+begin_src emacs-lisp 
(setq helm-ff-transformer-show-only-basename nil)
#+end_src
*** Extended Command, Insert, write and find files should use helm.

#+begin_src emacs-lisp 
(global-set-key (kbd "C-x C-f") 'helm-find-files)
(global-set-key (kbd "M-y")     'helm-show-kill-ring)
#+end_src

*** Personal Preferences
Make helm open a new window instead of taking over another.

Make it a bit nicer too.
#+begin_src emacs-lisp 
(setq helm-split-window-in-side-p t)
(setq helm-candidate-separator "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
#+end_src

* Footnotes

[fn:1] http://stackoverflow.com/questions/22039847/emacs-lisp-function-with-optional-argument-call-other-function#22040296

[fn:2] Thanks habamax and jwiegley. https://github.com/jwiegley/use-package/issues/366
